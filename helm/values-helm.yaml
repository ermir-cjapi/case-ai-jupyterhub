# JupyterHub Helm Values - Kubernetes Deployment
# This is the same as jupyterhub_config.py but in YAML format for Kubernetes

proxy:
  # Generate with: openssl rand -hex 32
  secretToken: "a7c63b7d74e9628282eca95874fa7a9f69797f027512bb6d9f0636bb9689307e"
  service:
    type: NodePort  # Expose on fixed port for Cloudflare tunnel
    nodePorts:
      http: 30080  # Fixed port - update Cloudflare to localhost:30080
  https:
    enabled: false  # Cloudflare handles TLS

hub:
  service:
    type: ClusterIP
  db:
    type: sqlite-pvc  # Simple SQLite database
  
  config:
    JupyterHub:
      admin_access: true
  
  # ============================================
  # AZURE AD CREDENTIALS FROM KUBERNETES SECRET
  # ============================================
  # Credentials are stored securely in Kubernetes secret.
  # 
  # To create the secret, run on your NVIDIA server:
  #   cd helm && ./create-azure-secret.sh
  #
  # This loads environment variables from the secret:
  # ============================================
  extraEnv:
    # Crypt key for auth_state encryption (required for group management)
    JUPYTERHUB_CRYPT_KEY:
      value: "2ed5854441fcd1d787df21fde8d18ead1ccd886b40cf9cbc48e2ae794e141eb4"
    AZURE_TENANT_ID:
      valueFrom:
        secretKeyRef:
          name: jupyterhub-azure-oauth
          key: tenant-id
    AZURE_CLIENT_ID:
      valueFrom:
        secretKeyRef:
          name: jupyterhub-azure-oauth
          key: client-id
    AZURE_CLIENT_SECRET:
      valueFrom:
        secretKeyRef:
          name: jupyterhub-azure-oauth
          key: client-secret
  
  extraConfig:
    # ============================================
    # UPGRADE OAUTHENTICATOR TO v17+ FOR GROUP SUPPORT
    # ============================================
    00-upgrade-oauthenticator: |
      import subprocess
      import sys
      import site
      print("Upgrading oauthenticator to v17+...")
      
      # Install to user directory
      subprocess.check_call([sys.executable, "-m", "pip", "install", "--user", "--upgrade", "--force-reinstall", "oauthenticator>=17.0.0"])
      
      # Put user site-packages at the FRONT of sys.path so it's checked first
      user_site = site.getusersitepackages()
      if user_site in sys.path:
          sys.path.remove(user_site)
      sys.path.insert(0, user_site)
      
      # Remove any already-imported oauthenticator modules from cache
      modules_to_remove = [key for key in sys.modules.keys() if key.startswith('oauthenticator')]
      for mod in modules_to_remove:
          del sys.modules[mod]
      
      print(f"oauthenticator v17+ installed to: {user_site}")
      print(f"Removed {len(modules_to_remove)} cached modules")
      print("sys.path[0] =", sys.path[0])
      print("oauthenticator upgrade complete!")
    
    # ============================================
    # AZURE AD / ENTRA ID AUTHENTICATION
    # ============================================
    # Credentials are loaded from Kubernetes secret (see extraEnv above).
    #
    # First-time setup:
    # 1. Create the secret: cd helm && ./create-azure-secret.sh
    # 2. Deploy JupyterHub: ./deploy_jhub_helm.sh
    #
    # To update credentials:
    # 1. Delete old secret: kubectl delete secret jupyterhub-azure-oauth -n jupyterhub-test
    # 2. Re-run: ./create-azure-secret.sh
    # 3. Restart hub: kubectl rollout restart deployment hub -n jupyterhub-test
    # ============================================
    01-azure-ad-auth: |
      import os
      from oauthenticator.azuread import AzureAdOAuthenticator
      c.JupyterHub.authenticator_class = AzureAdOAuthenticator
      
      # ============================================
      # CREDENTIALS FROM KUBERNETES SECRET
      # ============================================
      # These are loaded from environment variables (set via extraEnv above)
      # The actual values are stored in Kubernetes secret: jupyterhub-azure-oauth
      # ============================================
      
      c.AzureAdOAuthenticator.tenant_id = os.environ.get('AZURE_TENANT_ID')
      c.AzureAdOAuthenticator.client_id = os.environ.get('AZURE_CLIENT_ID')
      c.AzureAdOAuthenticator.client_secret = os.environ.get('AZURE_CLIENT_SECRET')
      c.AzureAdOAuthenticator.oauth_callback_url = "https://jupyterhub.ccrolabs.com/hub/oauth_callback"
      
      # ============================================
      # STEP 1: DEBUG - INSPECT TOKEN STRUCTURE
      # ============================================
      # We need to see WHERE groups are actually stored in the Azure AD token
      # ============================================
      
      # ============================================
      # GROUP-BASED AUTHORIZATION - WORKING CONFIG
      # ============================================
      # Groups found in: auth_state['user']['groups']
      # Format: List of group Object IDs (GUIDs)
      # ============================================
      
      # MUST enable auth_state for group management to work
      c.Authenticator.enable_auth_state = True
      
      # ============================================
      # FINAL SOLUTION: Azure AD Group Authorization
      # ============================================
      # Problem: oauthenticator v17 defaults to auth_state_groups_key = "user.groups"
      # But Azure AD puts groups in auth_state['id_token']['groups']
      # Solution: Use a callable to extract groups from the correct location
      # ============================================
      
      # Enable group management
      c.AzureAdOAuthenticator.manage_groups = True
      
      # Custom function to extract groups from id_token
      def get_groups_from_id_token(auth_state):
          """Extract groups from Azure AD id_token"""
          if auth_state and 'id_token' in auth_state:
              id_token = auth_state['id_token']
              if isinstance(id_token, dict) and 'groups' in id_token:
                  return id_token['groups']
          return []
      
      # Set auth_state_groups_key to our custom function
      c.AzureAdOAuthenticator.auth_state_groups_key = get_groups_from_id_token
      
      # Your actual group memberships:
      # - 4fb32c31-b135-43d5-a00e-9e566e6aceff
      # - d6c49ed5-eefc-48c4-90d0-2026f5fe3916 (JupyterHub-Admins)
      
      # Allow users in these groups
      c.AzureAdOAuthenticator.allowed_groups = {
          "4fb32c31-b135-43d5-a00e-9e566e6aceff",
          "d6c49ed5-eefc-48c4-90d0-2026f5fe3916",
          "6543851f-fd97-40e8-b097-ab5a71e44ef2"
      }
      
      # Admin group
      c.AzureAdOAuthenticator.admin_groups = {
          "d6c49ed5-eefc-48c4-90d0-2026f5fe3916"
      }
      
      
      # ============================================
      # OPTION B: Use Group Names (requires Azure AD Premium)
      # ============================================
      # If you have Azure AD Premium, you can configure Azure AD
      # to send group names instead of IDs. Uncomment below:
      #
      # c.AzureAdOAuthenticator.allowed_groups = {
      #     "JupyterHub-Users",
      #     "JupyterHub-Admins"
      # }
      # c.AzureAdOAuthenticator.admin_groups = {
      #     "JupyterHub-Admins"
      # }
      
      
      # ============================================
      # ALTERNATIVE: Email-Based Access Control (Not Recommended)
      # ============================================
      # If you prefer email-based control instead of groups, comment out the
      # allowed_groups and admin_groups above, and uncomment these:
      #
      # c.Authenticator.allowed_users = {
      #     "user1@yourcompany.com",
      #     "user2@yourcompany.com"
      # }
      # c.Authenticator.admin_users = {
      #     "admin@yourcompany.com"
      # }
      #
      # NOTE: Requires JupyterHub redeploy to add/remove users!
      # ============================================

    # ============================================
    # ALTERNATIVE: GitHub OAuth (Commented out)
    # ============================================
    # 00-github-auth: |
    #   from oauthenticator.github import GitHubOAuthenticator
    #   c.JupyterHub.authenticator_class = GitHubOAuthenticator
    #   
    #   c.GitHubOAuthenticator.client_id = "Ov23lidtVx7ofQPm6Qvz"
    #   c.GitHubOAuthenticator.client_secret = "ef282ca998be6a552b00f3ccfe62f18f195a9eae"
    #   c.GitHubOAuthenticator.oauth_callback_url = "https://jupyterhub.ccrolabs.com/hub/oauth_callback"
    #   c.Authenticator.allow_all = True
    #   c.Authenticator.admin_users = {"your-github-username"}
    
    # ============================================
    # ALTERNATIVE: No Authentication (Testing only)
    # ============================================
    # 00-simple-auth: |
    #   from jupyterhub.auth import DummyAuthenticator
    #   c.JupyterHub.authenticator_class = DummyAuthenticator
    #   c.DummyAuthenticator.password = ""
    #   c.Authenticator.admin_users = {"admin"}

singleuser:
  image:
    # Official JupyterHub base with GPU libraries
    name: docker.io/ermircjapi/jupyterhub-notebook
    tag: v2.3  # PyTorch nightly for RTX 5090 support (sm_120)
    pullPolicy: Always
  
  storage:
    type: dynamic
    capacity: 10Gi
    dynamic:
      storageClass: local-path  # k3s creates storage automatically
  
  # Start in JupyterLab
  defaultUrl: /lab
  
  # Fix PVC permissions using fsGroup
  extraPodConfig:
    securityContext:
      fsGroup: 100
      fsGroupChangePolicy: "OnRootMismatch"
  
  # Disable cloud metadata blocking (requires privileged init container)
  cloudMetadata:
    blockWithIptables: false
  
  # ============================================
  # USER PROFILES - Choose CPU or GPU at login
  # ============================================
  # Users select profile when logging in:
  # - CPU Only: Always available, for data exploration/light work
  # - GPU Enabled: Limited to 8 concurrent users (with time-slicing)
  # ============================================
  
  profileList:
    - display_name: "üíª CPU Only - Data Exploration"
      description: |
        üöÄ Always available (no waiting)
        üìä Perfect for: data analysis, visualization, pandas/numpy
        ‚ö° 2 CPUs, 4GB RAM
        ‚ùå No GPU access
      default: true
      kubespawner_override:
        cpu_limit: 2
        cpu_guarantee: 0.5
        mem_limit: "4G"
        mem_guarantee: "1G"
        # No GPU resources
    
    - display_name: "üéÆ GPU Enabled - ML/AI Training"
      description: |
        üî• 1 GPU slice (RTX 5090)
        ü§ñ Perfect for: PyTorch, TensorFlow, deep learning
        ‚ö° 4 CPUs, 8GB RAM, 1 GPU
        ‚è≥ May queue if 8 users active
      kubespawner_override:
        cpu_limit: 4
        cpu_guarantee: 1
        mem_limit: "8G"
        mem_guarantee: "2G"
        extra_resource_limits:
          nvidia.com/gpu: "1"
        extra_resource_guarantees:
          nvidia.com/gpu: "1"
  
  # ============================================
  # GPU TIME-SLICING CONFIGURATION
  # ============================================
  # IMPORTANT: GPU Time-Slicing must be configured first!
  # See: GPU-SHARING.md for details
  # 
  # With time-slicing enabled (replicas=8):
  # - 1 physical GPU becomes 8 virtual GPUs
  # - 8 users can work simultaneously on GPU profile
  # - Each gets ~12.5% when all active, 100% when alone
  # - Unlimited users on CPU-only profile
  #
  # Without time-slicing (default):
  # - Only 1 user at a time per physical GPU
  # - Other users wait in queue (Pending pods)
  #
  # To enable time-slicing on your cluster (RUN ONCE):
  #   ./setup-gpu-timeslicing.sh
  # ============================================

# Auto-shutdown idle notebooks
cull:
  enabled: true
  timeout: 3600   # 1 hour
  every: 600      # check every 10 minutes

# Keep image pulled
prePuller:
  continuous:
    enabled: true

# Disable user-scheduler (use default K3s scheduler)
scheduling:
  userScheduler:
    enabled: false
